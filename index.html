<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="utf-8">
    <title>Экзамен JavaScript</title>
    <link rel="stylesheet" href="lections.css" type="text/css">
</head>
<body>
<main>
    <ol class="baseNumeration">
        <h2>Основы JavaScript</h2>
        <li><h3>Типы данных</h3>
            <ul class="introduce"><b>Типов данных всего 6:</b>
                <li>Числа</li>
                <li>Строки</li>
                <li>Булевы величины</li>
                <li>Неопределенные величины</li>
                <li>Объекты и массивы</li>
                <li>Функции</li>
            </ul>
            <ol type="I">
                <li>Числа
                    <ul>
                        <li>Системы счисления
                            <ul>
                                <li><b>По умолчанию установлена десятичная</b></li>
                                <li>0x -- шестнадцатиричная</li>
                                <li>0o -- восьмеричная</li>
                                <li>0b -- бинарная</li>
                            </ul>
                        </li>
                        <li>Память
                            <ul>
                                <li>Отводится 64 бита под число:
                                    <ul>
                                        <li>1 бит под знак</li>
                                        <li>несколько под позици плавающей точки</li>
                                        <li>само число</li>
                                    </ul>
                                </li>
                                <li>0x -- шестнадцатиричная</li>
                                <li>0o -- восьмеричная</li>
                                <li>0b -- бинарная</li>
                            </ul>
                        </li>
                        <li>Экспоненциальная запись
                            <ul>
                                <li>2.9998e8</li>
                                <i>Представится как 2.9998 * 10^8 = 299980000</i>
                            </ul>
                        </li>
                        <li>Бесконечность
                            <ul>
                                <li>Infinity</li>
                                <li>-Infinity</li>
                                <i>По умолчанию больше (меньше) любого числа в JavaScript</i>
                            </ul>
                        </li>
                        <li>NaN (Not a Number)<br>
                            <i>Образуется в результате херовых операций с числами</i>
                        </li>
                        <li>Объекты, массивы, функции будут рассмотрены дальше</li>
                    </ul>
                </li>
                <li>Строки
                    <ul>
                        <li>Могут декларироваться одинарными или двойными кавычками</li>
                        <li>Некоторые символы приходится экранировать <br><i>например <span class="code">\\</span>
                            или <span class="code">\'</span> экранируются в <span class="code">\</span> и <span class="code">'</span> соответственно</i></li>
                        <li>Используют таблицу Unispan</li>
                        <li>Являются неизменяемыми</li>
                        <li>Методы:
                            <ul>
                                <li><span class="code">'...'.length</span>
                                     -- <i>Возвращает длину строки</i></li>
                                <li><span class="code">'...'.slice(..., ...)</span>
                                     -- <i>Принимает 2(1) аргумента, возвращает новую обрезанную с 1 по 2 аргумент строку</i></li>
                                <li><span class="code">'...'.indexOf(..., ...)</span>
                                     -- <i>Принимает 2(1) аргумента, возвращает true, если нашел подстроку, начиная со 2 аргумента</i></li>
                                <li><span class="code">'...'.toLowerCase()</span>
                                    -- <i>Приводит к нижнему регистру</i></li>
                                <li><span class="code">'...'.trim()</span>
                                    -- <i>Удаляет пробелы с начала и конца</i></li>
                                <li><span class="code">'...'.startsWith(...)</span>
                                    -- <i>Говорит, начинается ли строка с подстроки</i></li>
                            </ul>
                        </li>
                    </ul>
                </li>
                <li>Логический тип
                    <ul>
                        <li>true</li>
                        <li>false</li>
                    </ul>
                </li>
                <li>Неопределенные типы данных
                    <ul>
                        <li>undefined</li>
                        <li>null</li>
                    </ul>
                </li>
            </ol>
        </li>
        <li><h3>Оператор typeof</h3>
            <ul>
                <li>Возвращает тип аргумента</li>
                <li>Синтаксис оператора: <span class="code">typeof x;</span></li>
                <li>Синтаксис функции: <span class="code">typeof(x);</span></li>
                <li>Работают одинаково</li>
            </ul>
        </li>
        <li><h3>parseInt</h3> Принимает 2 аргумента:
            <ul>
                <li>Строка, которую необходимо преобразовать</li>
                <li>Система счисления, к которой необходимо преобразовать</li>
            </ul>
        </li>
        <li><h3>Number()</h3> Принимает 1 аргумент</li>
        <li><h3>parseFloat</h3> Принимает 1 аргумент</li>
        <li><h3>Переменные</h3> 2 способа декларации
            <ul>
                <li><span class="code">var</span></li>
                <li><span class="code">const и let</span></li> <i>введены в ES6</i>
            </ul>
        </li>
        <li><h3>Именование</h3>
            <ul>
                <li>Первый символ: <br> <span class="code">a-z     _       $</span></li>
                <li>Остальные символы: <br> <span class="code">a-z     A-Z     0-9     _       $</span></li>
                <li>Принятый стиль: <b>camelCase</b></li>
                <li>Запрещается использование ключевых слов в именах</li>
                <li>Если используется <span class="code">var</span>, константы именуются с большой буквы</li>
            </ul>
        </li>
        <li><h3>Комментарии</h3>
            <ul>
                <li>Блочные: <span class="code">/* ... */</span></li>
                <li>Строчные: <span class="code">// ...</span></li>
            </ul>
        </li>
        <li><h3>Операторы</h3> <b>В порядке уменьшения приоритета:</b>
            <ul>
                <li>Унарные
                    <ul>
                        <li>++</li><li>--</li><li>+</li><li>-</li><li>! (логическое отрицание)</li><hr class="operatorsPriority">
                    </ul>
                </li>
                <li>Бинарные
                    <ul>
                        <li>*</li><li>/</li><li>%</li><hr class="operatorsPriority">
                        <li>+</li><li>-</li><li>+ (конкатенация строк)</li><hr class="operatorsPriority">
                    </ul>
                </li>
                <li>Сравнения
                    <ul>
                        <li><</li><li><=</li><li>></li><li>>=</li>
                        <li>== (нестрогое сравнение (с приведением типов))</li>
                        <li>!=</li>
                        <li>=== (строгое сравнение (без приведения типов))</li>
                        <li>!==</li><hr class="operatorsPriority">
                    </ul>
                </li>
                <li>Логические
                    <ul>
                        <li>&&</li><hr class="operatorsPriority">
                        <li>||</li><hr class="operatorsPriority">
                    </ul>
                </li>
                <li>Присваивание
                    <ul>
                        <li>Простое</li>
                        <li>Составное</li>
                    </ul>
                </li>
                <li>Условные опреаторы
                    <ul>
                        <li><pre><span class="code-format">if(...) {
    ...
} else {
    ...
}</span></pre></li>
                        <li>Тернарный условный оператор<br><span class="code">(expression) ? true-block : false-block</span></li>
                        <li>switch-case:
<pre><span class="code-format">switch(expression) {
    case 'value1':
        ...
        [break];
    case 'value2':
        ...
        [break];
    ...
    default:
        ...
}</span></pre>
                        </li>
                    </ul>
                </li>
            </ul>
        </li>
        <li><h3>Точка с запятой (строгий режим и режим обратной совместимости)</h3>
            <ul>
                <li>Точка с запятой может не ставиться в нестрогом режиме, но это может привести к ошибке</li>
                <li>Для включения строгого режима в начале файла пишется: <span class="code">'use strict';</span></li>
            </ul>
        </li>
        <li><h3>Массивы</h3>
            <ul>
                <li>Спископодобный тип данных, который может хранить в себе список, содержащий значение (в том числе строки, массивы, etc)</li>
                <li>Итерирование по массиву может осуществляться циклом for или методом forEach</li>
                <li>Методы и свойства:
                    <ul>
                        <li><span class="code">[...].forEach(callback-function)</span>
                            -- <i>передается функция, которая 1 аргументом принимает текущий элемент, 2-м -- текущий индекс и делает всякие штуки</i></li>
                        <li><span class="code">[...].filter(callback-function)</span>
                            -- <i>передается аналогичная forEach-ной функция, но возвращает true или false, согласно которым строится новый массив из не только лишь всех элементов</i></li>
                        <li><span class="code">[...].map(callback-function)</span>
                            -- <i>передается аналогичная forEach-ной функция, но полученные значения запишутся в новый массив</i></li>
                        <li><span class="code">[...].join('...')</span>
                            -- <i>Принимает строчку и с ее помощью конкатинирует все элементы массива</i></li>
                        <li><span class="code">[...].length</span>
                            -- <i>Возвращает количество элементов в массиве</i></li>
                        <li><span class="code">[...].push(...)</span>
                            -- <i>Принимает новое значение и добавляет его в конец массива</i></li>
                        <li><span class="code">[...].pop()</span>
                            -- <i>Удаляет последний элемент массива и возвращает его</i></li>
                        <li><span class="code">[...].sort(callback-function)</span>
                            -- <i>Сортирует массив (может принимать функцию сортировки), по умолчанию сортирует по алфавиту</i></li>
                        <li><span class="code">[...].every(callback-function)</span>
                            -- <i>Проверяет, удовлетворяют ли ВСЕ элементы массива условию</i></li>
                        <li><span class="code">[...].some(callback-function)</span>
                            -- <i>Проверяет, удовлетворяет ли ХОТЯ БЫ ОДИН элемент массива условию</i></li>
                        <li><span class="code">[...].shift(...)</span>
                            -- <i>Удаляет первый элемент массива и возвращает его</i></li>
                        <li><span class="code">[...].unshift(...)</span>
                            -- <i>Принимает новое значение и добавляет его в начало массива</i></li>
                        <li><span class="code">[...].concat(другойМассив)</span>
                             -- <i>Объединяет массивы. <b>В результате образуется новый массив</b></i></li>
                        <li><span class="code">[...].slice</span>
                             -- <i>Работает, как и для строк, но если не передать параметры, вернет копию</i></li>
                        <li><span class="code">[...].splice(from, howMuch, '...')</span>
                             -- <i>from - откуда считаем, howMuch - сколько удаляем, последним - чем замещаем</i></li>
                        <li><b>reduce (охуевшая пизда)</b><br>
                            <span class="code">[...].reduce(callback-function, accumulator)</span>
                            <ul>
                                <li>callback-function получает 1 аргументом текущее значение аккумулятора,
                                вторым -- текущий обрабатываемый элемент в массиве
                                <br>возвращает значение, которое записывается в аккумулятор</li>
                                <li>accumulator может быть произвольного типа, в том числе и сложного</li>
                                <li>reduce можно херачить цепочками и делать вообще адовые вещи</li>
                                <li>после применения метода reduce получаем какое-то значение, которое надо куда-то записать</li>
                                <li><i>NB: если нихера не понятно -- лучше посмотреть
                                    <a href="https://www.coursera.org/learn/javascript-osnovy-i-funktsii/lecture/iZTEP/mietod-massiva-reduce">
                                    лекцию</a> или почитать в учебнике</i></li>
                            </ul>
                        </li>
                    </ul>
                </li>
                <li>Функции для работы с массивом можно вызывать друг за другом в цепочке, образуя <b><q>цепочку вызовов</q></b></li>
            </ul>
        </li>
        <li><h3>Объекты</h3>
            <ul>
                <li>Список, состоящий из пар ключ(свойство)-значение</li>
                <li>Ключ может быть строкой или числом (преобразуется к строке)</li>
                <li>Значение может быть произвольного типа</li>
                <li>Создание:
                    <pre><span class="code-format">let obj = {
    author: 'Petya',
    countRow: 18,
    haveSubscribe: true,
    childAuthor: {
        name: 'Lesha',
        age: 5
    }
}</span></pre><br><i>(под капотом во время присваивания вызывается конструктор <span class="code">= new Object({...})</span>)</i>
                </li>
                <li>Добавление свойства: <span class="code">объект.свойство = 'ето новое свойство типа строка';</span></li>
                <li>Добавление метода или свойства:
                    <pre class="expand3"><span class="code-format">Object.defineProperty(объект, 'toString', {         /* принимает объект,
название нового свойства и объект конфигурирования,
описывающий параметры свойства или метода */
    value: function() {     // м.б. примитив или функция
        return 'хаю-хай'
    },
    writable: true,         // перезаписываемое
    enumerable: false,      // перечисляемое (не возвращается при Object.keys(...), for (... in ...)... )
    configurable: true      // конфигурируемое и удаляемое (не связано с writable)
    // последние 3 по умолчанию <code>false</code>
});</span></pre>
                </li>
                <li>Также существует метод <span class="code">defineProperties</span>, позволяющий декларировать сразу несколько свойств объекта</li>
                <li>Метод <span class="code">Object.getOwnPropertyDesctiptor(объект, 'свойство')</span> позволяет получить данные об объекте конфигурирования свойства объекта</li>
                <li>Удаление свойства: <span class="code">delete объект.свойство;</span> -- <i>возвращает true или false</i></li>
                <li>Обращение:
                    <ul>
                        <li>Точечная нотация</li>
                        -- <span class="code">объект.свойство</span>
                        <li>Через [...] <i>(в скобках можно передать выражение)</i></li>
                        -- <span class="code">объект['свой' + 'ство']</span>
                    </ul>
                </li>
                <li>Итерирование: <span class="code">var ключ = Object.keys(объект);</span>
                     и <span class="code">for (... in ...) ...</span>
                    <ul>
                        <li>Возвращает массив строк (ключей) <i>NB: (это будут перечисляемые свойства)</i></li>
                        <li><i>Существует также Object.values(obj), но технология является экспериментальной</i></li>
                    </ul>
                </li>
                <li>Наличие свойства: <span class="code">объект.hasOwnProperty('свойство');</span>
                    <ul>
                        <li>Возвращает true или false</li>
                        <li>Кавычки писос как важны</li>
                    </ul>
                </li>
                <li><b>Геттеры и сеттеры</b> -- альтернативные способы декларации свойств и методов объекта
                    <ul>
                        <li>специальные методы объекта, которые вызываются при обращении к свойству на чтение и на запись</li>
                        <li>удобно при работе с динамическими свойствами, регулируя правила работы с ними и ограничения</li>
                        <li><pre class="expand"><span class="code-format">Object.defineProperty(объект, 'свойство', {
get: function() {
    return this.другоеСвойство;
},
set: function(value) {
    this.другоеСвойство = parseInt(value) || 0;
}
});</span></pre></li>
                        <li>Геттеры срабатывает при обращении на чтение, например <span class="code">объект.свойство</span><br>
                        Сеттер срабатывает при обращении на запись, как то: <span class="code">объект.свойство = 'cerf'</span></li>
                    </ul>
                </li>
                <li><b>Заморозка</b>
                    <ul>
                        <li>Задается при помощи <span class="code">Object.freeze(объект)</span></li>
                        <li>Убирает writable, configurable, но оставляет enumerable: true</li>
                        <li><span class="code">Object.isFrozen(объект)</span> возвращает true, если объект заморожен</li>
                    </ul>
                </li>
            </ul>
        </li>
        <li><h3>Объект Date</h3>
            <ul>
                <li><span class="code">new Date();</span> создает объект с текущей датой в системном часовом поясе</li>
                <li><span class="code">new Date('строка');</span> попытается преобразовать строку к дате</li>
                <li><span class="code">new Date(число);</span> преобразует как количество секунд, прошедших с полуночи (00:00:00 UTC) 1 января 1970 года (UNIX Timestamp)</li>
                <li><span class="code">new Date(число, число[, число, ...]);</span> год, месяц(начиная с 0) [, день, часы, минуты, секуды и мс</li>
                <li><span class="code">(new Date(что-то)).valueOf();</span> вернет UNIX Timestamp (секунды) от переданного</li>
                <li><span class="code">Date.now();</span> вернет текущий UNIX Timestamp (секунды)</li>
                <li><i>Старый, работает хуево. Образца Java 1995. Рекомендуется ознакомиться с документацией.</i></li>
            </ul>
        </li>
        <li><h3><b>Объект Math</b> -- библиотека мат. функций и констант</h3>
            <ul>
                <li><span class="code">Math.random();</span> возвращает случайное число от 0 до 1</li>
                <li><span class="code">Math.min(2 и более значений);</span> выбирает минимальное</li>
                <li><span class="code">Math.max(2 и более значений);</span> выбирает максимальное</li>
                <li>Округление
                    <ul>
                        <li><span class="code">Math.round(число);</span> округляет арифметически</li>
                        <li><span class="code">Math.floor(число);</span> округляет вниз</li>
                        <li><span class="code">Math.ceil(число);</span> округляет вверх</li>
                    </ul>
                </li>
                <li><span class="code">Math.log(число);</span> вернет натуральный логарифм</li>
                <li><span class="code">Math.pow(числоA, числоB);</span> вернет a<sup>b</sup></li>
                <li>Есть еще дохера, типа синус, тангенс, etc</li>
            </ul>
        </li>
        <li><h3>Функции</h3>
            <ul>
                <li>Именованный блок кода</li>
                <li>Позволяет повторно использовать код, рекурсивно его вызывать, <b>создавать область видимости</b></li>
                <li>Принцип DRY -- Don't repeat youself</li>

                <li>Может возвращать или не возвращать значение <i>NB: во втором случае неявно возвращает <code>undefined</code></i></li>
                <li>Являются объектами высшего порядка: <b><i><q>Могут быть переданы в другие функции в качестве аргумента,
                    а также могут иметь личные свойства, как и другие объекты</q></i></b></li>
                <li>Аргументы функции
                    <ul>
                        <li>Может иметь или не иметь входные параметры</li>
                        <li>Количество аргументов
                            <ul>
                                <li>БОльшее число параметров игнорируется</li>
                                <li>Меньшее -- остальные получаеют значение undefined</li>
                                <li>Решение -- проверки:
                                    <ul>
                                        <li>через if</li>
                                        <li>через <span class="code"> a = a || Infinity </span> <i>(апасно, нарушается семантика)</i></li>
                                    </ul>
                                </li>
                                <li><b>Именованные аргументы:</b> передается один аргумент (params), предполагающийся объектом с имеющимися полями:
                                    <pre><span class="code-format">function BMI(params) {
    var height = params.h;
    return params.w / (h * h);
}

BMI({w: 60, h: 1.7});</span></pre>
                                    <br>Достоинства:<i>удобен, если много необязательных аргументов, не важен порядок, неограниченное число аргументов, легко рефакторить</i>
                                    <br>Недостатки:<i>Неявный интерфейс, неудобно работать с аргументами внутри функции</i>
                                </li>
                                <li><b>Объект arguments</b> -- массивоподобный объект, содержащий передаваемые аргументы
                                <pre class="expand"><span class="code-format">function sum() {
    arguments.length;       // 2
    var a = arguments[0] || 0;   // первый аргумент
    var b = arguments[1] || 0;   // второй аргумент
    return a + b;
}

sum(5, 3);                           // 8
sum(3);                              // 3</span></pre>
                                    <i>ето <b>не массив</b>, но может им стать: <span class="code">var args = [].slice.call(arguments);</span></i></li>
                                    <li class="introduce">Метод call:
                                        <img src="call.png" alt="" class="image-code">
                                    </li>
                            </ul>
                        </li>
                        <li>Входные параметры передаются по значению или по ссылке:
                            <ul>
                                <li>По значению передаются примитивы: число, строка, etc
                                <br><i>В этом случае все, что происходило с ним внутри функции, остается внутри функции (копируется)</i></li>
                                <li>По ссылке передаются сложные типы данных: массив, объект, функция, etc
                                <br><i>В этом случае все изменения с этими данными изменяют передаваемый параметр, работая непосредственно с ним</i></li>
                            </ul>
                        </li>
                        <li>Объявления функции
                            <ul>
                                <li><b>function declaration:</b> <i>обычное объявление</i><br>можно вызвать до объявления</li>
                                <li><b>function expression:</b> <i>функция присваивается переменной, описывается без имени</i>
                                    <br>нельзя вызвать до объявления</li>
                                <li><b>named function expression:</b>
                                    <pre class="expand"><span class="code-format">var fact = function inner(n) {
    return n === 1 ? 1 : n * inner(n-1);
}</span></pre><br>имя переменной доступно только снаружи, имя функции доступно только изнутри
                                </li>
                                <li><b>Конструктор функции:</b> <span class="code">var add = new Function('a', 'b', 'return a+b');</span>
                                <br><b>не рекомендуется к использованию</b><i>(может быть полезен для конструирования функции на лету)</i></li>
                            </ul>
                        </li>
                    </ul>
                </li>
            </ul>
        </li>
        <li><h3>Обработка исключений</h3>
            <ul>
                <li>Применяется для того, чтобы не обрабатывать все возможные варианты
                    всех возможных значений, а просто кинуть ошибку, если данные хуевые</li>
                <li><span class="code">throw new TypeError('Vse huevo');</span></li>
                <li>Могут быть разные ошибки на все случаи жизни</li>
                <li>Как правило на практике используется конструкция try ... catch</li>
                <li><pre class="expand2"><span class="code-format">try {
    /* всякие штуки, которые могут вызвать исключение */
} catch(e) {
    /* обработка исключение, с помощью instanceof NAMEERROR */
    /* e -- это объект исключения, содержит поля name, message, stack */
}</span></pre></li>
            </ul>
        </li>
        <li><h3>Сравнение разных типов данных</h3>
            <ul>
                <li><b>Объект и строка:</b>
                    <ul>
                        <li>Сначала к левому и правому операндам применяется внутренний метод isPrimitive(...),
                            отвечающий, является ли он примитивным типом</li>
                        <li>Проверяет, существует ли у левого операнда функция .toString: <br>
                        <span class="code">typeof операнд.toString === 'function'; // true или false</span></li>
                        <li>Если функция есть, то она применяется и сравнивается результат ее работы со строкой</li>
                    </ul>
                </li>
                <li>Сравнение двух сложных типов данных почти всегда вернет false,
                    кроме случая, когда оба объекта ссылаются на один и тот же объект в памяти</li>
                <li>Существует строгое и нестрогое сравнение (=== и ==). Второе допускает неявное
                    преобразование левого операнда к типу правого<i>NB: рекомендуется всегда юзать строгое</i></li>
                <li>Приведение объекта к строке:
                    <ul>
                        <li><span class="code">String(объект);</span></li>
                        <li><span class="code">'' + объект;</span></li>
                    </ul>
                </li>
            </ul>
        </li>
        <li><h3>Регулярные выражения</h3>
            <ul>
                <li>Записывается внутри /.../</li>
                <li>Существуют флаги, пишущиеся после /.../(СЮДА), например, <span class="code">g</span> (глобальное сопоставление) или <span class="code">i</span> (игнор регистра)</li>
                <li>Две функции для работы с регвырами:
                    <ul>
                        <li><span class="code">регвыр.test(что-то)</span> проверяет содержание регвыра в строке</li>
                        <li><span class="code">регвыр.replace(что-то)</span> замена подстроки в строке на основе регвыра</li>
                    </ul>
                </li>
                <li>Обрамление регвыра в круглые скобки <span class="code">/(...)/</span> "вынимает найденные данные из строки" и отправляет в переменную $N, где N -- уровень вложенности скобок</li>
                <li>Имеют PCRE-совместимый синтаксис (Perl Compatible Regular Expression)</li>
            </ul>
        </li>
        <li><h3>Область видимости</h3>
            <ul>
                <li><b>Глобальная</b> (переменная или функция объявлена в глобальном объекте, если она объявлена не в теле другой функции)</li>
                <li><b>Локальная</b> (в нее помещаются все переменные и аргумент, объявленные в функции)</li>
                <li>в ES6 <a href="http://jsraccoon.ru/es6-block-scoped-declarations">добавлена</a> <b>блочная</b> область видимости</li>
                <li>Интерпретатор видит переменные, объявленные в родителе и выше</li>
                <li><b>Затенение</b> -- если внутри одной функции объявляется другая с именем переменной,
                    которое уже существовало в родительской, то на время работы дочерней функции
                    эта переменная принимает ближайшее значение</li>
            </ul>
        </li>
        <li><h3>Всплытие</h3>
            <ul>Существует 2 условных части исполнения кода:
                <li>Инициализация: код просматривается на предмет инициализации переменных и функций
                    <ul>
                        <li>переменные всплывают только в пределах области видимости</li>
                        <li>функция не всплывет, если объявлена через function expression,
                            ибо функция окажется в переменной только в момент присваивания </li>
                    </ul>
                </li>
                <li>Выполнение</li>
            </ul>
        </li>
        <li>
            <h3><q>Замыкание -- функция со всеми ее внешними переменными, к которым она имеет доступ</q></h3>
            <ul>
                <li>Очистка мусора при выделении памяти под новую переменную происходит за счет механизма <q>счетик ссылок:</q><br>
                будет ненулевым, если к переменной есть доступ в данный момент
                (даже неявно, например, при вызове извне функции, в которой данная переменная определена)</li>
                <li><i>NB: Паттерн "модуль" также создает область видимости, чтобы переменные имели внутри нее уникальные имена</i>
                <br>чтобы воспользоваться им, можно использовать IIFE (immediately-invoked function expression):
                <pre><span class="code-format">var func = (function () {
    ...
}());</span></pre><br>теперь из-за механизма "Затенение" испортить функции внутри func нельзя</li>
            </ul>
        </li>
        <li>
            <h3>this и контекст исполнения</h3>
            <ul>
                <li><b>Контекст исполнения</b> тесно связан с областью видимости и содержит ее.<br>
                    <b>Кроме нее</b>, содержит еще и ключевое слово <b>this</b></li>
                <li><b>this</b>
                    <ul>
                        <li>this работает почти так же, как и везде, свойства:
                            <ul>
                                <li>ключевое слово</li>
                                <li>нельзя перезаписать</li>
                                <li>указывает на текущий объект</li>
                                <li><b>можно использовать за пределами объекта</b></li>
                            </ul>
                        </li>
                        <li>this опредяляется в момент интерпретации участка кода (в функции в момент <b>вызова</b>)</li>
                        <li>this зависит от следующих параметров:
                            <ul>
                                <li>Тип участка кода
                                    <ul>
                                        <li>Глобальный:
                                            <ul>
                                                <li>в бразуере в глобальной области видимости this ссылается на window</li>
                                                <li>в Node.js в глобальной области видимости this ссылается на global</li>
                                                <li><span class="code">console.log();</span> также вызывается
                                                    у глобального объекта, работает аналогично: <span class="code">this.console.log();</span></li>
                                            </ul>
                                        </li>
                                        <li>Node.js модуль:
                                            <ul>
                                                <li><span class="code">module.exports.свойство = значение;</span>
                                                работает так же, как и <span class="code">this.свойство = значение;</span></li>
                                                <li>импорт модуля осуществялется при помощи <span class="code">var value = require('./модуль');</span>
                                                <br><i>(NB: в качестве результата получаем "тот самый объект, который мы (кто "мы"?) экспортировали из модуля</i></li>
                                            </ul>
                                        </li>
                                    </ul>
                                </li>
                                <li>Как мы попали на этот участок (кто "мы"?) !! разобраться
                                    <ul>
                                        <li>Если функция объявлена в глобальной области видимости, то this внутри функции ссылается на global/window</li>
                                        <li>Если функция описана в модуле Node.js, то this вернет объект, экспортируемый этим самым (почему "самым"??) модулем</li>
                                        <li>Если функция вызвана в качестве значения поля объекта, то this будет ссылаться на этот объект</li>
                                        <li>ЕСЛИ <b>функция</b> кладется в память в качестве <b>значения</b> некоторой <b>переменной</b>,
                                            то this внутри нее будет ссылаться на глобальный объект, <b>притом не важно,
                                            где была определена функция</b><br><i>(Такое поведение называется <q>заимствование метода</q>)</i></li>
                                        <li>Если функция была передана в качестве callback, то его контекст как бы явно не задан
                                            и в качестве this подставляется global <b>(Проблема)</b>:
                                            <ul>
                                                <li>сохранить контекст исполнения в переменную:
                                                    <span class="code">var _this = this;</span></li>
                                                <li>в языке предусмотрена передача контекста исполнения callback'a вторым аргументом
                                                    <br><i>(не все функции, работающие с callback, принимают его контекст выполнения
                                                        -- на помощь придет <span class="code">.bind();</span>, описанный ниже)</i>
                                                </li>
                                            </ul>
                                        </li>
                                        <li>this будет ссылаться на объект, от которого был позван метод даже если
                                            интерпретатор нашел метод в цепочке его прототипов</li>
                                        <hr class="logicDiv">
                                        <li>Методы:
                                            <ul>
                                                <li><span class="code">.call()</span>(вызывается у функции)
                                                <br><i>вызывает функцию с указанным значением this и индивидуально предоставленными аргументами:
                                                    <span class="code">function.call(thisArg, arg1, arg2, ...);</span>
                                                <br>может быть использован для использования чужих методов у какого-либо объекта</i></li>
                                                <li><span class="code">.apply()</span>(вызывается у функции)
                                                <br><i>вызывает функцию с указанным значением this и агрументами в виде массива:
                                                    <span class="code">function.apply(thisArg, [arg1, arg2, ...]);</span>
                                                <br>может быть использован для того, чтобы передать аргументы в виде массива (ваш кэп)</i></li>
                                                <li><span class="code">.bind()</span>(вызывается у функции)
                                                <br><i>создает новую функцию, устанавливающую при вызове контекст исполнения
                                                    this предоставленное значение:
                                                    <span class="code">function.bind(thisArg, arg1, arg2, ...]);</span>
                                                <br>по факту записывается как и передача контекста вторым аргументом, только вместо
                                                <span class="code">}, this);</span> подставляется <span class="code">}.bind(this));</span></i></li>
                                                <li>также .bind() позволяет использовать "частичное применение":
                                                    <pre class="expand"><span class="code-format">var binPow = Math.pow.bind(null, 2);
binPow(2); // 4
binPow(8); // 256</span></pre></li>
                                                <li><i><b>(NB: можно передавать и null в качестве this)</b></i></li>
                                            </ul>
                                        </li>
                                    </ul>
                                </li>
                                <li>Режим работы интерпретатора:
                                    <ul>
                                        <li>В режиме обратной совместимости this совпадает с контекстом,
                                            в котором была вызвана функция</li>
                                        <li>В строгом режиме для функции, вызванной в global значение this -- undefined</li>
                                        <li>Функция <span class="code">eval(...);</span> используется в js для того, чтобы
                                        интерпретировать код, написанный в виде строки (в т.ч. можно обращаться ко
                                        внешним переменным и юзать this):
                                            <ul>
                                                <li>если eval работает внутри метода объекта, то ссылается на этот объект</li>
                                                <li>если eval работает внутри метода объекта неявно (через объявление переменной),
                                                    то ссылается на глобальный объект</li>
                                            </ul>
                                        </li>
                                    </ul>
                                </li>
                            </ul>
                        </li>
                    </ul>
                </li>
            </ul>
        </li>
        <hr><h2>Прототипы и асинхронность, Node.js</h2>
        <li>
            <h3>Прототипы</h3>
            <ul>
                <li><b>Определение.</b>Представляют собой объекты, на которые указывает ссылка во внутреннем поле [[Prototype]]</li>
                <li>Являются способом избавления от проблемы дублирования кода (аналогично функциям),
                    выделяя общий части кода в отдельный объект</li>
                <li>Прототипами, как правило, являются некоторые базовые конструкции,
                    с помощью которых создаются более законченные</li>
                <li><i>Рефакторинг можно осуществить с помощью метода call, но это неудобно,
                    хотелось бы вызывать методы и свойства, как родные для объекта</i></li>
                <li>Для внедрения прототипирования у объекта существует специально поле [[Prototype]]
                    <br><i>для записи в него ссылки на другой объект существует несколько способов:</i>
                    <ul>
                        <li>Сеттер/геттер <b>__proto__</b>:
                            <span class="code">объект.__proto__ = другойОбъект</span>
                            <br><i>появился только в ES6</i></li>
                        <li><span class="code">Object.create(...)</span>
                            -- принимает в качестве параметра желаемый прототип
                            <br>делает больше работы, чем нам здесь надо и создает только новые объекты
                            <br><b>создать объект с самой короткой цепочкой прототипов:
                                <span class="code">var qqq = Object.create(null);</span></b></li>
                        <li>метод <span class="code">setPrototypeOf(..., ...)</span>
                            -- принимает объект и его желаемый прототип
                            <ul>Ведет себя "лучше", чем __proto__, хотя и схож с ним:
                                <li>выкидывает ошибку при попытке присвоить дерьмо (напр. число)</li>
                                <li>существует обратный метод <span class="code">getPrototypeOf()</span>,
                                    возвращающий ссылку на прототип (появился раньше)</li>
                            </ul>
                        </li>
                    </ul>
                </li>
                <li>Как это работает:
                    <ul>
                        <li>Если при обращении соответствующего поля у объекта не обнаружено, то
                            интерпретатор будет искать его в прототипе, затем в прототипе прототипа
                            и так далее, пока не встретит null в поле [[Prototype]]</li>
                        <li>По умолчанию любой объект в поле [[Prototype]] имеет ссылку на
                            глобальный прототип, содержащий общие методы для всех объектов
                            (например, <span class="code">Object.prototype.toString())</span>
                            <br><i>уже глобальный прототип имеет <span class="code">null</span>
                                в поле [[Prototype]]</i></li>
                        <li>Существуют более локальные прототипы, например Array.prototype</li>
                        <img class="image-code" src="prototype-chain.png">
                        <li>Циклическое прототипирование выкидывает эксепшен</li>
                        <li>Если попытаться поменять значение, которого нет у объекта,
                            но есть в его прототипе, то произойдет добавление поля к объекту
                            и <q>эффект затенение свойства</q>
                            <br><b><i>(Благодаря этому эффекту можно добиться и затенения общих
                                методов из глобального прототипа)</i></b></li>
                        <li>Особенности работы <span class="code">writable</span>:<br>
                            <b>Однако, если установить <span class="code">writable: false;</span>
                            свойству прототипа, то новое свойство у объекта прописать не получится
                            и присваивания также не произойдет (эффект затенения не будет работать)
                            , что логично, но контринтуитивно</b></li>
                        <li>Особенности работы сеттеров/геттеров (set/get):<br>
                            <b>Также, если поле в прототипе определено с помощью <span class="code">
                            set: ...</span> или <span class="code">get: ...</span>, то эффект
                            затенения также работать не будет и присваивания не произойдет</b></li>
                        <li>Особенности работы <span class="code">enumerable</span>:<br>
                            <ul>
                                <li>Оператор <span class="code">for ... in</span> перечисляет не
                                    только свойства самого объекта, но и свойства его прототипа</li>
                                <li><span class="code">объект.hasOwnProperty('свойство');</span>
                                    позволяет вывести только собственные поля объекта через оператор
                                    <span class="code">for ... in</span>, если это необходимо</li>
                                <li>Оператор <span class="code">Object.keys()</span> сразу вернет
                                только собственные значения объекта</li>
                                <li>В глобальных прототипах все поля неперечисляемые по умолчанию</li>
                            </ul>
                        </li>
                    </ul>
                </li>
            </ul>
        </li>
        <li>
            <h3>Конструкторы</h3>
            <ul>
                <li><h4>Классический метод через прототипы:</h4>
                    <ul>
                        <li>Решают проблему дублирования кода при создании большого количества однотипных объектов</li>
                        <li>Можно запилить самому: <pre class="expand"><span class="code-format">function createStudent(name) {
    return {
        name: name,
        sleep: function () {
            console.info('zzz...');
        }
    };
}</span></pre>, однако, тогда придется каждый раз создавать новый метод (здесь: <span class="code">sleep()</span>
<br>Решение: вынести методы в прототип:<img class="image-code" src="constructor.png"></li>
                        <li>Конструкторы, которые встроены в язык JavaScript:
                            <ul>
                                <li>Любая функция с оператором new (можно указывать поля при помощи
                                    ключевого слова <span class="code">this</span>, т.к. фактически
                                    оно будет указывать на создаваемый объект (формально это не совсем так:
                                    в функции в this неявно записывается пустой объект, затем он наполняется
                                    свойствами и после возврается (также неявно))
                                </li>
                                <li>Объект-прототип для конструктора хорошо бы прописать в специальное поле:
                                    <img class="image-code" src ="prototype-in-new.png">
                                    <br>данное поле <span class="code">.prototype</span>:<ul>
                                        <li>во 1) есть у каждой функции</li>
                                        <li>вовторых хранит объект</li>
                                        <li>втетьих 3)имеет смысл только при вызове функции как конструктора</li>
                                        <ul>хранимый в поле <span class="code">.prototype</span> объект изначально
                                        непуст и хранит особое поле <span class="code">.constructor</span>:
                                            <li>неперечисляемое</li>
                                            <li>хранит ссылку на саму функцию-конструктор, например, чтобы посмотреть
                                                , с помощью какой функции был сконструирован объект
                                            </li>
                                            <li><b>НА КАРТИНКЕ -- НЕ ВЕРНО!!</b>, т.к. убивается поле
                                            <span class="code">.constructor</span> при перезаписи
                                            <span class="code">Student.prototype</span>. Логичнее поле
                                            <span class="code">.prototype</span> просто дополнять методами</li>
                                        </ul>
                                    </ul>

                                </li>
                                <li>Функции-конструкторы по договоренности именуются с Заглавной буквы.
                                    <br>Если накосячить и вызвать ее не как конструктор, то можно записать
                                    в глобальный объект лишнюю хуйню. А это не есть хорошо. <br><i>(фиксится
                                    включением строгого режима)</i>
                                </li>
                                <li>Если "испортить" функцию-конструктор, возвращая что-то явно, то:
                                    <ul>
                                        <li>Если явно возвращается объект, интерпретатор допускает это</li>
                                        <li>Иначе -- игнорирует наш return</li>
                                    </ul>
                                </li>
                            </ul>
                        </li>
                        <li>Цепочки прототипов при создании объекта конструктором:
                            <ul>Проблема: хочу вызвать методы из прототипа одного объекта в другом объекте,
                                у которого уже есть прототип:<br>
                                <img class="image-code inline" src="prototype-constructor-chain.png">
                                <img class="image-code inline" src="new-chain2.png">
                                <li>Можно записать <span class="code">Student.prototype = Person.prototype;</span>, затем
                                дополнить его полями: <span class="code">Student.prototype.sleep = function () {...};</span></li>
                                <li>Будет работать для него, но, формально выражаясь, все прототипы конструкторов,
                                    передаваемые друг в друга, будут хранить ссылку на один и тот же объект, таким образом,
                                конструктор Person и вовсе перестанет быть универсальным, т.к. будет иметь в поле
                                <span class="code">.prototype</span> объект с полем <span class="code">sleep</span>.
                                <br><br>В сухом остатке: <img class="image-code" src="new-chain1.png">
                                </li>
                                <li>Поможет метод <span class="code">Object.create(...)</span>, принимающий в
                                качестве аргумента желаемый прототип для возвращаемого методом значения:
                                <span class="code">Student.prototype = Object.create(Person.prototype);</span>
                                <br>Также придется вручную вернуть поле <span class="code">.constructor</span>
                                <br><i>(подробнее про .create: <a href="https://www.coursera.org/learn/javascript-prototipy/lecture/zcjAi/konstruktory-i-tsiepochki-prototipov">
                                по ссылке</a>)</i></li>
                                <li></li>
                            </ul>
                        </li>
                        <li>Инспектирование связей:
                            <ul>
                                <li>Метод <span class="code">getPrototypeOf(...)</span></li>
                                <li>Метод <span class="code">isPrototypeOf(...)</span> -- отвечает на вопрос:
                                <q>является ли объект прототипом объекта, передаваемого в аргументе?</q>
                                <br><span class="code">Student.prototype.isPrototypeOf(billy); // true</span>
                                <br>Также корректно работает и с цепочкой прототипов (вплоть до глобального):
                                <br><span class="code">Person.prototype.isPrototypeOf(billy); // true</span></li>
                                <li>оператор <span class="code">instanceof</span>:
                                <br>делает примерно то же самое, работает по цепочке (1-я зависимость, null,
                                2-ая зависимость, ...): <img class="image-code" src="instanceof.png">
                                <br><i>(Разумеется, если "там null", возвращается false:
                                    <span class="code">var qq = Object.create(null); <br>
                                    qq instanceof Object; // false</span>)</i></li>
                            </ul>
                        </li>
                        <li>Если вдруг захочется избежать дублирования кода в конструкторах, можно вынести
                            код в общий прототип, но тогда необходимо вызвать конструктор прототипа внутри
                            конструктора объекта: <pre class="expand2"><span class="code-format">function Student(name) {
    Person.call(this, name); // this ссылается на новый объект студента
}</span></pre> </li>
                        <li>Если хочется вызвать затеняемый метод в затеняющем, то можно воспользоваться
                            пресловутым методом <span class="code">.call()</span>:
                            <img class="image-code" src="call-shadow.png">
                        </li>
                    </ul>
                </li>
                <li><h4>Метод .create</h4>
                    <ul>
                        <li>Чтобы не париться с кучей сложных зависимостей, просто для каждого
                            нового объекта в цепочке прототипов хуярим <span class="code">Object.create()</span>
                            от предыдущего прототипа, дополняем своими полями и полчучаем, что надо.
                            При создании экземпляра также
                            используем <span class="code">Object.create()</span> (а че бы нет?)
                        </li>
                        <li>метод <span class="code">Object.create()</span> на самом деле приниает 2 аргумента:
                        вторым аргументом передаются поля со своими начальными значениями, которые хочется ЕЩЕ
                        увидеть при создании объекта: <img src="2-args-create.png" class="image-code">
                        </li>
                        <li>фабрика объектов -- это функция, помогающая спавнить объекты
                            <br>возвращает объект со всеми предыдущими полями и дополнительными,
                            которые передаются 2-м аргументом:
                            <img src="create-factory.png" class="image-code">
                        </li>
                    </ul>
                </li>
                <li><h4>Классы</h4>
                    <ul>
                        <li>Добавлены в новой версии спецификации</li>
                        <li>Похожи на нормальный адекватный ООП</li>
                        <li>По факту представляют собой обычные конструкторы</li>
                        <li><span class="code">typeof имяКласса</span> вернет <span class="code">function</span></li>
                    </ul>
                </li>
                <li><h4>Сухой остаток</h4>
                    Все способы являются верными. "Классы" предпочтительнее перед функциями-конструкторами
                    в виду доп. ограничений. Использование <span class="code">Object.create()</span> позволяет
                    строить более гибкие функции <i>(например, миксины) (сказать только, если спросят!!)</i>
                </li>
            </ul>
        </li>
        <li><h3>Асинхронность</h3>
            <ul>
                <li>Введем несколько новых понятий:
                    <ul>
                        <li><b>Стек вызовов</b> -- структура, которой оперирует интерпретатор.
                            Хранит текущие функции, внутри которых находится этот самый (почему "самый"??)
                            интерпретатор в том порядке, в котором они вызывались.
                            При исполнении кода внизу стека всегда лежит IIFE
                            <br>При выбрасывании исключения выводится стек вызовов для удобства дебагинга
                            <br>Сюда функция попадает либо из очереди, либо если вызывается новая функция
                            внутри той, которая уже есть на стеке
                        </li>
                        <li><b>Очередь событий</b> -- подносит новые функции в стек вызовов, когда он пуст.
                            Формально после того, как очередь событий не сможет в очередной раз передать
                            новую функция в стек вызовов, программа закончит работу.
                        </li>
                        Вместе они образуют <b>Цикл событий</b>
                    </ul>
                </li>
                <li>Системные таймеры
                    <ul>
                        <li>setTimeout
                            <ul>
                                <li><span class="code">setTimeout(func[, delay, arg1, ...])</span></li>
                                <li>func будет положена в очередь событий единожды по прошествии delay(ms)</li>
                                <li>Интерпретатор заводит системный таймер на delay и по прошествии
                                    delay сработает системный таймер и функция func попадает в очередь событий
                                </li>
                            </ul>
                        </li>
                        <li>setInterval
                            <ul>
                                <li><span class="code">setInterval(func[, delay, arg1, ...])</span></li>
                                <li>func будет класться в очередь событий каждый раз по прошествии delay</li>
                                <li>для остановки системного таймера используется метод
                                    <span class="code">clearInterval(id);</span>, который очистит системный таймер
                                    <i>(NB: id -- результат
                                    вызова метода setInterval (предварительно присвоим его в id))</i>
                                </li>
                            </ul>
                        </li>
                    </ul>
                </li>
                <li>Асинхронные операции как способы положить функцию в очередь событий
                    <ul>
                        <li>Чтобы положить функция в Event Queue, можно выполнить асинхронную операцию,
                            в результате которой будет вызван callback -- функция обратного вызова.
                        </li>
                        <li>Во время синхронных операций интерпретатор не может выполнять другую полезную
                            работу, основной поток выполнения блокируется</li>
                        <li>В случае асинхронной операции ошибка передается в callback, тогда как
                            синхронная сразу кидает эксепшен
                        </li>
                        <li>Способы работы с асинхронным кодом
                            <ul>
                                <li>callback передается последним параметром:
                                    <ul>
                                        <li>Первым аргументом принимает ошибку, если ее нет -- null</li>
                                        <li>Вторым аргументом передаются данные, с которыми завершилась операция</li>
                                        <li>Достоинства:
                                            <ul>
                                                <li>Нет накладных расходов</li>
                                                <li>Не нужно ничего подключать</li>
                                                <li>Самый быстрый высокопроизводительный код</li>
                                                <li>Используется для написание кода внешней библиотеки</li>
                                                <li>Являются стандартном работы с асинхронным кодом</li>
                                            </ul>
                                        </li>
                                        <li>Недостатки:
                                            <ul>
                                                <li>Глубокая вложенность (саб-зиро)</li>
                                                <li>Ошибки и данные обрабатываются в одном куске кода</li>
                                                <li>Невнимательность как причина необработки всех исключений</li>
                                                <li>Лишние переменные в результате обраной синхрнизации</li>
                                            </ul>
                                        </li>
                                    </ul>
                                </li>
                                <li>Promises
                                    <ul>
                                        <li>Вызывается конструктором промиса, принимающий первым аргументом
                                            функцию, внутри которой содержится работа с асинхронным кодом.
                                        </li>
                                        <li>Эта функция принимает первым аргументом успешные данные, вторым ошибку</li>
                                        <li>Promise имеет 3 состояния:
                                            <br>неопределенное (начальное), fulfilled и rejected (оба конечные),
                                            во второе промис переходит при возникновении ошибки в callback</li>
                                        <li>Результат работы промиса передается в обработчики:
                                            <ul>
                                                <li><span class="code">.then(func1 (data) {}, func2 (err) {})</span></li>
                                                <li><span class="code">.then(console.log, console.error)</span></li>
                                            </ul>
                                        </li>
                                        <li>Достоинства:
                                                <ul>
                                                    <li>Ловятся некотрнолируемые исключения</li>
                                                    <li>Можно настроить несколько обработчиков (цепочка промисов)</li>
                                                </ul>
                                            </li>
                                        <li>Недостатки:
                                            <ul>
                                                <li>Дополнительная обертка </li>
                                                <li>Медленнее, чем callback</li>
                                            </ul>
                                        </li>
                                    </ul>
                                </li>
                                <li>Цепочка промисов
                                    <ul>
                                        <li>Промис после работы своего .then создает новый промис</li>
                                        <li>Можно до посинения вызывать новые .then и обрабатывать вообще все</li>
                                        <li>Пригодится, если ошибки могут возникнуть в разных местах
                                            и на разных этапах:
                                            <img src="promises-chain.png" alt="" class="image-code">
                                        </li>
                                        <li>Теперь можно повыкидвать identity и thrower и в первом случае
                                            вызвать .catch() вместо .then(), а во втором просто передать .then()
                                            с одним аргументом
                                        </li>
                                    </ul>
                                </li>
                                <li>Параллельное выполнение промисов <pre><span class="code-format">Promise
   .all([массив промисов])
   .then(func);</span></pre> </li>
                                <li>Можно создать промис без совершения асинхронных операций,
                                    надо его сразу зарезолвить или зареджектить: <pre><span class="code-format">Promise
   .resolve('{"name": "serezha"}')
   .then(console.log);</span></pre>
                                    В этих случаях промис сразу переходит в указанное состоянии с теми данными,
                                    которые мы передали в скобки resolve или reject
                                </li>
                            </ul>
                        </li>
                    </ul>
                </li>
            </ul>
        </li>
        <li>
            <h3>Node.js</h3>
            <ul>
                <li><b>Введение, история, общие понятия</b>
                    <ul>
                        <li>Операции в веб-приложении:
                            <ul>
                                <li>Чтение HTTP-запроса  -- I/O-bound</li>
                                <li>Парсинг запроса -- CPU-bound</li>
                                <li>Запрос к базе данных -- I/O-bound</li>
                                <li>Запрос к API -- I/O-bound</li>
                                <li>Генерация HTML -- CPU-bound</li>
                                <li>Отправка HTML -- I/O-bound</li>
                            </ul>
                        </li>
                        <li>Оптимизация I/O-bound операция позволит улучшить работу веб-сервера</li>
                        <li>В рамках одного потока одновременно исполняется только одна операция</li>
                        <li>Блокирующий ввод-вывод накладывает существенные ограничения на производительность:
                            <img src="blocking-io.png" alt="" class="image-code">
                        </li>
                        <li>Решения проблемы:
                            <ul>
                                <li><b>Multithreading</b> -- поднятие еще 1 потока
                                    <br>Ограничения:
                                    <ul>
                                        <li>Небесплатная операция (можно обойтись пуллом
                                            подготовленных заранее потоков)</li>
                                        <li>Есть лимит на количество поднимаемых потоков в ОС</li>
                                        <li>Требует отдельной памяти на каждый поток</li>
                                    </ul>
                                </li>
                                <li><b>Неблокирующий ввод/вывод</b> -- ОС регистрирует запрос и возвращает управление
                                    <br>Принцип работы:
                                    <ul>
                                        <li>Регистрация происходит в Event Demultiplexer (resorce, operation, callback)</li>
                                        <li>После готовности, ED кладет в Event Queue событие о том, что ресурс готов вместе с cb</li>
                                        <li>Event Loop в бесконечном цикле разбирает очередь, вызывая обработчики, выполняющиеся
                                            на стороне приложения. После этого забирает управления назад, разбирая новое событие.
                                        </li>
                                    </ul>
                                    Весь механизм более полно описан в паттерне <b>Reactor</b><br>
                                    <img src="non-blocking-io.png" alt="" class="image-code inline">
                                    <img src="cycle.png" alt="" class="image-code inline">
                                </li>
                                <li>Apache vs Nginx</li>
                            </ul>
                        </li>
                        <li>Node.js была создана разработчиком по имени Ryan Dahl:
                            <br>написал обертку libuv для работы с I/O и доработал ее
                        </li>
                        <li>Для взаимодействия с неблокирующим I/O нужно указать ссылку на обработчик результата (callback)
                            <br>Для этого синхронные методы меняются на асинхронные
                            Этот паттерн(callback) cледует 2 правилам:
                            <ul>
                                <li>cb всегда передается последним аргументом</li>
                                <li>Ошибка в cb передается первым аргументом</li>
                            </ul>
                        </li>
                        <li>Почему JavaScript?
                            <ul>
                                <li>во 1) есть функции первого класса и замыкания,
                                    то бишь можно передавать функцию в качестве параметра</li>
                                <li>вовторых язык готов к работе с Event Loop (уже взаимодействует с ним в браузере)
                                    <br>DOM-events, setTimeout
                                </li>
                                <li>втетьих 3)JS простой -> имеет большое комьюнити</li>
                            </ul>
                        </li>
                        <li>Для привлечения аудитории "в коробку" был написан "Core JavaScript API":
                            <ul>
                                <li>fs API, работающий с файловой системой</li>
                                <li>http API, работающий с запросами</li>
                                <li>console API, работающий с логированием</li>
                            </ul>
                        </li>
                        <li>По итогу для связки движка V8, библиотеки libuv, и Core JS API были написаны
                            специальные bindings, связывающие C, C++, JS коды</li>
                        <li>Все это в компоновке дало платформу Node.js</li>
                    </ul>
                </li>
                <li>Модули -- фундаментальный блок кода для структурирования приложения в Node.js
                    <ul>
                        <li>Модуль -- обычный js-файл</li>
                        <li>Если модуль реиспользуется между приложениями -- это пакет</li>
                        <li>Чтобы модуль приносил пользу -- необходимо экспортировать из него основную функцию</li>
                        <li>Перед интерпретацией Node.js добавляет в модуль специальный объект
                            <span class="code">module</span> c метаинформацией о нем (в частности, полный путь
                            до файла с модулем и пустой объект <span class="code">exports</span> )
                        </li>
                        <li>В другом файле мы импортируем модуль при помощи функции
                            <span class="code">require(./название.js);</span> и на выход получаем то,
                            что положили в объект при экспорте
                        </li>
                        <li><i>Экспортировать можно любые типы данных: функции, числа, конструкторы, объекты, etc</i></li>
                        <li>Можно импортировать встроенные модули, которых довольно много, при помощи
                            <span class="code">require('название');</span></li>
                        <li>Можно импортировать сторонние модули других разработчиков,
                            которых баснословно много, при помощи <span class="code">require('название');</span></li>
                        <li><b>Модуль импортируется один раз</b> и после первого require для данного модуля
                            результат кешируется в специальном свойстве require.cache</li>
                        <li>Алгоритм поиска испортируемой функции: сначала проверка на встроенный, затем проверка на
                            то, что начинается с './', '/' или '../', последним -- поиск в node_modules начиная с
                            текущей директории и вверх
                        </li>
                    </ul>
                </li>
                <li>Пакетный менеджер npm (Node Package Manager)
                    <ul>Это инструмент командной строки, ставится вместе с нодой, команды:
                        <li><span class="code">npm init</span> -- создает манифест package.json для описания модуля:
                            <ul>
                                <li>package.json вместе с самим модулем образует пакет</li>
                                <li>Содержит название, версию, зависимости и много разного</li>
                            </ul>
                        </li>
                        <li><span class="code">npm search ...</span> -- поиск пакета в хранилище по имени</li>
                        <li><span class="code">npm show ...</span> -- основная информация о пакете</li>
                        <li><span class="code">npm install ...</span> -- установка пакета в качестве зависимости в node_modules
                            <br><i>(подзависимости установятся как зависимости у зависимости)</i>
                        </li>
                        <li><span class="code">npm install ...@2.3.4</span> -- установка определенной версии:
                            <img src="versions.png" alt="" class="image-code">
                        </li>
                        <li>Зависимости фиксируются в манивесте в разделе "dependencies"</li>
                        <li>Если "dependencies" заполнить вручную, а затем вызвать
                            <span class="code">npm install</span>, то все установится само:
                            <ul>
                                <li>различные символы перед номером версии или вместо него
                                    задают "хотелки" для версии (>1.2.3, ^1.2.3, ...)</li>
                                <li>можно передать теги (latest, ...)</li>
                                <li>можно указать git-url даже с тегом, веткой или коммитом</li>
                                <li>еще много чего</li>
                            </ul>
                        </li>
                        <li>Опции файла .npmrc:
                            <ul>
                                <li><span class="code">save=true</span>
                                    -- npm install теперь всегда фиксирует зависимости</li>
                                <li><span class="code">save-exact=true</span>
                                    -- npm install теперь всегда строго фиксирует версию</li>
                                <li><span class="code">init-author-name='serezha'</span>
                                    -- включает автозаполнение для полей npm init'a</li>
                            </ul>
                        </li>
                    </ul>
                </li>
                <li>http-клиент и http-сервер на Node.js
                    (для того, чтобы принимать запросы пользователей и отвечать на них
                    или наоборот сделать запрос и прочитать ответ от сервера)
                    <br>отлично подходит модуль http: <span class="code">require('http');</span>,
                    <span class="code">require('url');</span>, <span class="code">require('querystring');</span>
                    <br>модуль использует EventEmitter, часто использующийся в модулях для организации
                    процесса подписки на события, отписки и пр.
                    <br>лучше посмотреть <a href="https://www.coursera.org/learn/javascript-prototipy/lecture/oHaBE/http-kliient-i-http-siervier-na-node-js">видяшку</a>
                </li>
                <li>Работа с файловой системой:
                    <ul>
                        <li>используется модуль 'fs', позволяющий асинхронно прочитать файлы</li>
                        <li>используется модуль 'buffer' для работы с бинарными данными</li>
                        <li>содержимое файла -- это бинарные данные, читается либо с помощью
                            метода toString(), либо указав кодировку в качестве параметра fs.readFile</li>
                        <li>что еще умеет модуль fs?
                            <ul>
                                <li>fs.appednFile();</li>
                                <li>fs.writeFile();</li>
                                <li>fs.unlink(); -- удалить файл</li>
                                <li>fs.mkdir(); -- работать с директориями</li>
                                <li>fs.watch(); -- позволяет следить за содержимым файла</li>
                                <li><b>Предоставляет синхронные аналоги для всех функций,
                                    которые блокируют поток выполнения</b></li>
                            </ul>
                        </li>
                    </ul>
                </li>
            </ul>
        </li>
    </ol>
</main>
</body>
</html>
