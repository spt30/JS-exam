<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="utf-8">
    <title>Экзамен JavaScript</title>
    <link rel="stylesheet" href="lections.css" type="text/css">
</head>
<body>
    <input id="tnum0" type="radio" name="tasks-number" checked>
    <label for="tnum0" id="tt">НИКАКОЙ БИЛЕТ НЕ ВЫБРАН</label>
    <input id="tnum1" type="radio" name="tasks-number">
    <label for="tnum1">1</label>
    <input id="tnum2" type="radio" name="tasks-number">
    <label for="tnum2">2</label>
    <input id="tnum3" type="radio" name="tasks-number">
    <label for="tnum3">3</label>
    <input id="tnum4" type="radio" name="tasks-number">
    <label for="tnum4">4</label>
    <input id="tnum5" type="radio" name="tasks-number">
    <label for="tnum5">5</label>
    <input id="tnum6" type="radio" name="tasks-number">
    <label for="tnum6">6</label>
    <input id="tnum7" type="radio" name="tasks-number">
    <label for="tnum7">7</label>
    <input id="tnum8" type="radio" name="tasks-number">
    <label for="tnum8">8</label>
    <input id="tnum9" type="radio" name="tasks-number">
    <label for="tnum9">9</label>
    <input id="tnum10" type="radio" name="tasks-number">
    <label for="tnum10">10</label>
    <input id="tnum11" type="radio" name="tasks-number">
    <label for="tnum11">11</label>
    <input id="tnum12" type="radio" name="tasks-number">
    <label for="tnum12">12</label>
    <input id="tnum13" type="radio" name="tasks-number">
    <label for="tnum13">13</label>
    <input id="tnum14" type="radio" name="tasks-number">
    <label for="tnum14">14</label>
    <input id="tnum15" type="radio" name="tasks-number">
    <label for="tnum15">15</label>
    <input id="tnum16" type="radio" name="tasks-number">
    <label for="tnum16">16</label>
    <input id="tnum17" type="radio" name="tasks-number">
    <label for="tnum17">17</label>
    <input id="tnum18" type="radio" name="tasks-number">
    <label for="tnum18">18</label>
    <input id="tnum19" type="radio" name="tasks-number">
    <label for="tnum19">19</label>
    <input id="tnum20" type="radio" name="tasks-number">
    <label for="tnum20">20</label>
    <input id="tnum21" type="radio" name="tasks-number">
    <label for="tnum21">21</label>
    <ol class="baseNumeration">
        <h2>Основы JavaScript</h2>
        <li><h3>Типы данных</h3>
            <ul class="introduce"><b>Типов данных всего 6:</b>
                <li>Числа</li>
                <li>Строки</li>
                <li>Булевы величины</li>
                <li>Неопределенные величины</li>
                <li>Объекты и массивы</li>
                <li>Функции</li>
            </ul>
            <ol type="I">
                <li>Числа
                    <ul>
                        <li>Системы счисления
                            <ul>
                                <li><b>По умолчанию установлена десятичная</b></li>
                                <li>0x -- шестнадцатиричная</li>
                                <li>0o -- восьмеричная</li>
                                <li>0b -- бинарная</li>
                            </ul>
                        </li>
                        <li>Память
                            <ul>
                                <li>Отводится 64 бита под число:
                                    <ul>
                                        <li>1 бит под знак</li>
                                        <li>несколько под позици плавающей точки</li>
                                        <li>само число</li>
                                    </ul>
                                </li>
                                <li>0x -- шестнадцатиричная</li>
                                <li>0o -- восьмеричная</li>
                                <li>0b -- бинарная</li>
                            </ul>
                        </li>
                        <li>Экспоненциальная запись
                            <ul>
                                <li>2.9998e8</li>
                                <i>Представится как 2.9998 * 10^8 = 299980000</i>
                            </ul>
                        </li>
                        <li>Бесконечность
                            <ul>
                                <li>Infinity</li>
                                <li>-Infinity</li>
                                <i>По умолчанию больше (меньше) любого числа в JavaScript</i>
                            </ul>
                        </li>
                        <li>NaN (Not a Number)<br>
                            <i>Образуется в результате херовых операций с числами</i>
                        </li>
                        <li>Объекты, массивы, функции будут рассмотрены дальше</li>
                    </ul>
                </li>
                <li>Строки
                    <ul>
                        <li>Могут декларироваться одинарными или двойными кавычками</li>
                        <li>Некоторые символы приходится экранировать <br><i>например <span class="code">\\</span> 
                            или <span class="code">\'</span> экранируются в <span class="code">\</span> и <span class="code">'</span> соответственно</i></li>
                        <li>Используют таблицу Unispan</li>
                        <li>Являются неизменяемыми</li>
                        <li>Методы:
                            <ul>
                                <li><span class="code">'...'.length</span>
                                     -- <i>Возвращает длину строки</i></li>
                                <li><span class="code">'...'.slice(..., ...)</span>
                                     -- <i>Принимает 2(1) аргумента, возвращает новую обрезанную с 1 по 2 аргумент строку</i></li>
                                <li><span class="code">'...'.indexOf(..., ...)</span>
                                     -- <i>Принимает 2(1) аргумента, возвращает true, если нашел подстроку, начиная со 2 аргумента</i></li>
                                <li><span class="code">'...'.toLowerCase()</span>
                                    -- <i>Приводит к нижнему регистру</i></li>
                                <li><span class="code">'...'.trim()</span>
                                    -- <i>Удаляет пробелы с начала и конца</i></li>
                                <li><span class="code">'...'.startsWith(...)</span>
                                    -- <i>Говорит, начинается ли строка с подстроки</i></li>
                            </ul>
                        </li>
                    </ul>
                </li>
                <li>Логический тип
                    <ul>
                        <li>true</li>
                        <li>false</li>
                    </ul>
                </li>
                <li>Неопределенные типы данных
                    <ul>
                        <li>undefined</li>
                        <li>null</li>
                    </ul>
                </li>
            </ol>
        </li>
        <li><h3>Оператор typeof</h3>
            <ul>
                <li>Возвращает тип аргумента</li>
                <li>Синтаксис оператора: <span class="code">typeof x;</span></li>
                <li>Синтаксис функции: <span class="code">typeof(x);</span></li>
                <li>Работают одинаково</li>
            </ul>
        </li>
        <li><h3>parseInt</h3> Принимает 2 аргумента:
            <ul>
                <li>Строка, которую необходимо преобразовать</li>
                <li>Система счисления, к которой необходимо преобразовать</li>                
            </ul>
        </li>
        <li><h3>Number()</h3> Принимает 1 аргумент</li>
        <li><h3>parseFloat</h3> Принимает 1 аргумент</li>
        <li><h3>Переменные</h3> 2 способа декларации
            <ul>
                <li><span class="code">var</span></li>
                <li><span class="code">const и let</span></li> <i>введены в ES6</i>
            </ul>
        </li>
        <li><h3>Именование</h3>
            <ul>
                <li>Первый символ: <br> <span class="code">a-z     _       $</span></li>
                <li>Остальные символы: <br> <span class="code">a-z     A-Z     0-9     _       $</span></li>
                <li>Принятый стиль: <b>camelCase</b></li>
                <li>Запрещается использование ключевых слов в именах</li>
                <li>Если используется <span class="code">var</span>, константы именуются с большой буквы</li>
            </ul>
        </li>
        <li><h3>Комментарии</h3>
            <ul>
                <li>Блочные: <span class="code">/* ... */</span></li>
                <li>Строчные: <span class="code">// ...</span></li>
            </ul>
        </li>
        <li><h3>Операторы</h3> <b>В порядке уменьшения приоритета:</b>
            <ul>
                <li>Унарные
                    <ul>
                        <li>++</li><li>--</li><li>+</li><li>-</li><li>! (логическое отрицание)</li><hr class="operatorsPriority">
                    </ul>
                </li>
                <li>Бинарные
                    <ul>
                        <li>*</li><li>/</li><li>%</li><hr class="operatorsPriority">
                        <li>+</li><li>-</li><li>+ (конкатенация строк)</li><hr class="operatorsPriority">
                    </ul>
                </li>
                <li>Сравнения
                    <ul>
                        <li><</li><li><=</li><li>></li><li>>=</li>
                        <li>== (нестрогое сравнение (с приведением типов))</li>
                        <li>!=</li>
                        <li>=== (строгое сравнение (без приведения типов))</li>
                        <li>!==</li><hr class="operatorsPriority">
                    </ul>
                </li>
                <li>Логические
                    <ul>
                        <li>&&</li><hr class="operatorsPriority">
                        <li>||</li><hr class="operatorsPriority">
                    </ul>
                </li>
                <li>Присваивание
                    <ul>
                        <li>Простое</li>
                        <li>Составное</li>
                    </ul>
                </li>
                <li>Условные опреаторы
                    <ul>
                        <li><pre><span class="code-format">if(...) { 
        ...
} else {
        ...
}</span></pre></li>
                        <li>Тернарный условный оператор<br><span class="code">(expression) ? true-block : false-block</span></li>
                        <li>switch-case:
<pre><span class="code-format">switch(expression) {
        case 'value1':
                ...
                [break];
        case 'value2':
                ...
                [break];
        ...
        default:
                ...
}</span></pre>
                        </li>
                    </ul>
                </li>
            </ul>
        </li>
        <li><h3>Точка с запятой (строгий режим и режим обратной совместимости)</h3>
            <ul>
                <li>Точка с запятой может не ставиться в нестрогом режиме, но это может привести к ошибке</li>
                <li>Для включения строгого режима в начале файла пишется: <span class="code">'use strict';</span></li>
            </ul>
        </li>
        <li><h3>Массивы</h3>
            <ul>
                <li>Спископодобный тип данных, который может хранить в себе список, содержащий значение (в том числе строки, массивы, etc)</li>
                <li>Итерирование по массиву может осуществляться циклом for или методом forEach</li>
                <li>Методы и свойства:
                    <ul>
                        <li><span class="code">[...].forEach(callback-function)</span>
                            -- <i>передается функция, которая 1 аргументом принимает текущий элемент, 2-м -- текущий индекс и делает всякие штуки</i></li>
                        <li><span class="code">[...].filter(callback-function)</span>
                            -- <i>передается аналогичная forEach-ной функция, но возвращает true или false, согласно которым строится новый массив из не только лишь всех элементов</i></li>
                        <li><span class="code">[...].map(callback-function)</span>
                            -- <i>передается аналогичная forEach-ной функция, но полученные значения запишутся в новый массив</i></li>
                        <li><span class="code">[...].join('...')</span>
                            -- <i>Принимает строчку и с ее помощью конкатинирует все элементы массива</i></li>
                        <li><span class="code">[...].length</span>
                            -- <i>Возвращает количество элементов в массиве</i></li>
                        <li><span class="code">[...].push(...)</span>
                            -- <i>Принимает новое значение и добавляет его в конец массива</i></li>
                        <li><span class="code">[...].pop()</span>
                            -- <i>Удаляет последний элемент массива и возвращает его</i></li>
                        <li><span class="code">[...].sort(callback-function)</span>
                            -- <i>Сортирует массив (может принимать функцию сортировки), по умолчанию сортирует по алфавиту</i></li>
                        <li><span class="code">[...].every(callback-function)</span>
                            -- <i>Проверяет, удовлетворяют ли ВСЕ элементы массива условию</i></li>
                        <li><span class="code">[...].some(callback-function)</span>
                            -- <i>Проверяет, удовлетворяет ли ХОТЯ БЫ ОДИН элемент массива условию</i></li>
                        <li><span class="code">[...].shift(...)</span>
                            -- <i>Удаляет первый элемент массива и возвращает его</i></li>
                        <li><span class="code">[...].unshift(...)</span>
                            -- <i>Принимает новое значение и добавляет его в начало массива</i></li>
                        <li><span class="code">[...].concat(другойМассив)</span>
                             -- <i>Объединяет массивы. <b>В результате образуется новый массив</b></i></li>
                        <li><span class="code">[...].slice</span>
                             -- <i>Работает, как и для строк, но если не передать параметры, вернет копию</i></li>
                        <li><span class="code">[...].splice(from, howMuch, '...')</span>
                             -- <i>from - откуда считаем, howMuch - сколько удаляем, последним - чем замещаем</i></li>
                        <li><b>reduce (охуевшая пизда)</b><br>
                            <span class="code">[...].reduce(callback-function, accumulator)</span>
                            <ul>
                                <li>callback-function получает 1 аргументом текущее значение аккумулятора,
                                вторым -- текущий обрабатываемый элемент в массиве
                                <br>возвращает значение, которое записывается в аккумулятор</li>
                                <li>accumulator может быть произвольного типа, в том числе и сложного</li>
                                <li>reduce можно херачить цепочками и делать вообще адовые вещи</li>
                                <li>после применения метода reduce получаем какое-то значение, которое надо куда-то записать</li>
                                <li><i>NB: если нихера не понятно -- лучше посмотреть 
                                    <a href="https://www.coursera.org/learn/javascript-osnovy-i-funktsii/lecture/iZTEP/mietod-massiva-reduce">
                                    лекцию</a> или почитать в учебнике</i></li>
                            </ul>
                        </li>
                    </ul>
                </li>
                <li>Функции для работы с массивом можно вызывать друг за другом в цепочке, образуя <b><q>цепочку вызовов</q></b></li>
            </ul>
        </li>
        <li><h3>Объекты</h3>
            <ul>
                <li>Список, состоящий из пар ключ(свойство)-значение</li>
                <li>Ключ может быть строкой или числом (преобразуется к строке)</li>
                <li>Значение может быть произвольного типа</li>
                <li>Создание:
                    <pre><span class="code-format">let obj = {
        author: 'Petya',
        countRow: 18,
        haveSubscribe: true,
        childAuthor: {
                name: 'Lesha',
                age: 5
        }
}</span></pre>
                </li>
                <li>Добавление свойства: <span class="code">объект.свойство = 'ето новое свойство типа строка';</span></li>
                <li>Добавление метода или свойства:
                    <pre class="expand2"><span class="code-format">Object.defineProperty(объект, 'toString', {         /* принимает объект, 
название нового свойства и объект конфигурирования, 
описывающий параметры свойства или метода */
        value: function() {     // м.б. примитив или функция
                return 'хаю-хай'
        },
        writable: true,         // перезаписываемое      
        enumerable: false,      // перечисляемое (не возвращается при Object.keys(...))
        configurable: true      // конфигурируемое и удаляемое (не связано с writable)
        // последние 3 по умолчанию <code>false</code>
});</span></pre>
                </li>
                <li>Также существует метод <span class="code">defineProperties</span>, позволяющий декларировать сразу несколько свойств объекта</li>
                <li>Метод <span class="code">Object.getOwnPropertyDesctiptor(объект, 'свойство')</span> позволяет получить данные об объекте конфигурирования свойства объекта</li>
                <li>Удаление свойства: <span class="code">delete объект.свойство;</span> -- <i>возвращает true или false</i></li>
                <li>Обращение:
                    <ul>
                        <li>Точечная нотация</li>
                        -- <span class="code">объект.свойство</span>
                        <li>Через [...] <i>(в скобках можно передать выражение)</i></li>
                        -- <span class="code">объект['свой' + 'ство']</span>
                    </ul>
                </li>
                <li>Итерирование: <span class="code">var ключ = Object.keys(объект);</span>
                    <ul>
                        <li>Возвращает массив строк (ключей) <i>NB: (это будут перечисляемые свойства)</i></li>
                        <li><i>Существует также Object.values(obj), но технология является экспериментальной</i></li>
                    </ul>
                </li>
                <li>Наличие свойства: <span class="code">объект.hasOwnProperty('свойство');</span>
                    <ul>
                        <li>Возвращает true или false</li>
                        <li>Кавычки писос как важны</li>
                    </ul>
                </li>
                <li><b>Геттеры и сеттеры</b> -- альтернативные способы декларации свойств и методов объекта
                    <ul>
                        <li>специальные методы объекта, которые вызываются при обращении к свойству на чтение и на запись</li>
                        <li>удобно при работе с динамическими свойствами, регулируя правила работы с ними и ограничения</li>
                        <li><pre class="expand"><span class="code-format">Object.defineProperty(объект, 'свойство', {
get: function() {
        return this.другоеСвойство;
},
set: function(value) {
        this.другоеСвойство = parseInt(value) || 0;
}
});</span></pre></li>
                        <li>Геттеры срабатывает при обращении на чтение, например <span class="code">объект.свойство</span><br>
                        Сеттер срабатывает при обращении на запись, как то: <span class="code">объект.свойство = 'cerf'</span></li>
                    </ul>
                </li>
                <li><b>Заморозка</b>
                    <ul>
                        <li>Задается при помощи <span class="code">Object.freeze(объект)</span></li>
                        <li>Убирает writable, configurable, но оставляет enumerable: true</li>
                        <li><span class="code">Object.isFrozen(объект)</span> возвращает true, если объект заморожен</li>
                    </ul>
                </li>
            </ul>
        </li>
        <li><h3>Объект Date</h3>
            <ul>
                <li><span class="code">new Date();</span> создает объект с текущей датой в системном часовом поясе</li>
                <li><span class="code">new Date('строка');</span> попытается преобразовать строку к дате</li>
                <li><span class="code">new Date(число);</span> преобразует как количество секунд, прошедших с полуночи (00:00:00 UTC) 1 января 1970 года (UNIX Timestamp)</li>
                <li><span class="code">new Date(число, число[, число, ...]);</span> год, месяц(начиная с 0) [, день, часы, минуты, секуды и мс</li>
                <li><span class="code">(new Date(что-то)).valueOf();</span> вернет UNIX Timestamp (секунды) от переданного</li>
                <li><span class="code">Date.now();</span> вернет текущий UNIX Timestamp (секунды)</li>
                <li><i>Старый, работает хуево. Образца Java 1995. Рекомендуется ознакомиться с документацией.</i></li>
            </ul>
        </li>
        <li><h3><b>Объект Math</b> -- библиотека мат. функций и констант</h3>
            <ul>
                <li><span class="code">Math.random();</span> возвращает случайное число от 0 до 1</li>
                <li><span class="code">Math.min(2 и более значений);</span> выбирает минимальное</li>
                <li><span class="code">Math.max(2 и более значений);</span> выбирает максимальное</li>
                <li>Округление
                    <ul>
                        <li><span class="code">Math.round(число);</span> округляет арифметически</li>
                        <li><span class="code">Math.floor(число);</span> округляет вниз</li>
                        <li><span class="code">Math.ceil(число);</span> округляет вверх</li>
                    </ul>
                </li>
                <li><span class="code">Math.log(число);</span> вернет натуральный логарифм</li>
                <li><span class="code">Math.pow(числоA, числоB);</span> вернет a<sup>b</sup></li>
                <li>Есть еще дохера, типа синус, тангенс, etc</li>
            </ul>
        </li>
        <li><h3>Функции</h3>
            <ul>
                <li>Именованный блок кода</li>
                <li>Позволяет повторно использовать код, рекурсивно его вызывать, <b>создавать область видимости</b></li>
                <li>Принцип DRY -- Don't repeat youself</li>
                
                <li>Может возвращать или не возвращать значение <i>NB: во втором случае неявно возвращает <code>undefined</code></i></li>
                <li>Являются объектами высшего порядка: <b><i><q>Могут быть переданы в другие функции в качестве аргумента, 
                    а также могут иметь личные свойства, как и другие объекты</q></i></b></li>
                <li>Аргументы функции
                    <ul>
                        <li>Может иметь или не иметь входные параметры</li>
                        <li>Количество аргументов
                            <ul>
                                <li>БОльшее число параметров игнорируется</li>
                                <li>Меньшее -- остальные получаеют значение undefined</li>
                                <li>Решение -- проверки: 
                                    <ul>
                                        <li>через if</li>
                                        <li>через <span class="code"> a = a || Infinity </span> <i>(апасно, нарушается семантика)</i></li>
                                    </ul>
                                </li>
                                <li><b>Именованные аргументы:</b> передается один аргумент (params), предполагающийся объектом с имеющимися полями:
                                    <pre><span class="code-format">function BMI(params) {
        var height = params.h;
        return params.w / (h * h);
}

BMI({w: 60, h: 1.7});</span></pre>
                                    <br>Достоинства:<i>удобен, если много необязательных аргументов, не важен порядок, неограниченное число аргументов, легко рефакторить</i>
                                    <br>Недостатки:<i>Неявный интерфейс, неудобно работать с аргументами внутри функции</i>
                                </li>
                                <li><b>Объект arguments</b> -- массивоподобный объект, содержащий передаваемые аргументы
                                <pre class="expand"><span class="code-format">function sum() {
        arguments.length;       // 2
        var a = arguments[0] || 0;   // первый аргумент
        var b = arguments[1] || 0;   // второй аргумент
        return a + b;
}

sum(5, 3);                           // 8
sum(3);                              // 3</span></pre>
                                    <i>ето <b>не массив</b>, но может им стать: <span class="code">var args = [].slice.call(arguments);</span></i></li>
                                    <li class="introduce">Метод call:
                                        <img src="call.png" alt="" class="image-code">
                                    </li>
                            </ul>
                        </li>
                        <li>Входные параметры передаются по значению или по ссылке:
                            <ul>
                                <li>По значению передаются примитивы: число, строка, etc
                                <br><i>В этом случае все, что происходило с ним внутри функции, остается внутри функции (копируется)</i></li>
                                <li>По ссылке передаются сложные типы данных: массив, объект, функция, etc
                                <br><i>В этом случае все изменения с этими данными изменяют передаваемый параметр, работая непосредственно с ним</i></li>
                            </ul>
                        </li>
                        <li>Объявления функции
                            <ul>
                                <li><b>function declaration:</b> <i>обычное объявление</i><br>можно вызвать до объявления</li>
                                <li><b>function expression:</b> <i>функция присваивается переменной, описывается без имени</i>
                                    <br>нельзя вызвать до объявления</li>
                                <li><b>named function expression:</b> 
                                    <pre class="expand"><span class="code-format">var fact = function inner(n) {
        return n === 1 ? 1 : n * inner(n-1);
}</span></pre><br>имя переменной доступно только снаружи, имя функции доступно только изнутри
                                </li>
                                <li><b>Конструктор функции:</b> <span class="code">var add = new Function('a', 'b', 'return a+b');</span>
                                <br><b>не рекомендуется к использованию</b><i>(может быть полезен для конструирования функции на лету)</i></li>
                            </ul>
                        </li>
                    </ul>
                </li>
            </ul>
        </li>
        <li><h3>Обработка исключений</h3>
            <ul>
                <li>Применяется для того, чтобы не обрабатывать все возможные варианты 
                    всех возможных значений, а просто кинуть ошибку, если данные хуевые</li>
                <li><span class="code">throw new TypeError('Vse huevo');</span></li>
                <li>Могут быть разные ошибки на все случаи жизни</li>
                <li>Как правило на практике используется конструкция try ... catch</li>
                <li><pre class="expand2"><span class="code-format">try {
        /* всякие штуки, которые могут вызвать исключение */
} catch(e) {
        /* обработка исключение, с помощью instanceof NAMEERROR */
        /* e -- это объект исключения, содержит поля name, message, stack */
}</span></pre></li>
            </ul>
        </li>
        <li><h3>Сравнение разных типов данных</h3>
            <ul>
                <li><b>Объект и строка:</b>
                    <ul>
                        <li>Сначала к левому и правому операндам применяется внутренний метод isPrimitive(...), 
                            отвечающий, является ли он примитивным типом</li>
                        <li>Проверяет, существует ли у левого операнда функция .toString: <br>
                        <span class="code">typeof операнд.toString === 'function'; // true или false</span></li>
                        <li>Если функция есть, то она применяется и сравнивается результат ее работы со строкой</li>
                    </ul>
                </li>
                <li>Сравнение двух сложных типов данных почти всегда вернет false, 
                    кроме случая, когда оба объекта ссылаются на один и тот же объект в памяти</li>
                <li>Существует строгое и нестрогое сравнение (=== и ==). Второе допускает неявное
                    преобразование левого операнда к типу правого<i>NB: рекомендуется всегда юзать строгое</i></li>
                <li>Приведение объекта к строке:
                    <ul>
                        <li><span class="code">String(объект);</span></li>
                        <li><span class="code">'' + объект;</span></li>
                    </ul>
                </li>
            </ul>
        </li>
        <li><h3>Регулярные выражения</h3>
            <ul>
                <li>Записывается внутри /.../</li>
                <li>Существуют флаги, пишущиеся после /.../(СЮДА), например, <span class="code">g</span> (глобальное сопоставление) или <span class="code">i</span> (игнор регистра)</li>
                <li>Две функции для работы с регвырами:
                    <ul>
                        <li><span class="code">регвыр.test(что-то)</span> проверяет содержание регвыра в строке</li>
                        <li><span class="code">регвыр.replace(что-то)</span> замена подстроки в строке на основе регвыра</li>
                    </ul>
                </li>
                <li>Обрамление регвыра в круглые скобки <span class="code">/(...)/</span> "вынимает найденные данные из строки" и отправляет в переменную $N, где N -- уровень вложенности скобок</li>
                <li>Имеют PCRE-совместимый синтаксис (Perl Compatible Regular Expression)</li>
            </ul>
        </li>
        <li><h3>Область видимости</h3>
            <ul>
                <li><b>Глобальная</b> (переменная или функция объявлена в глобальном объекте, если она объявлена не в теле другой функции)</li>
                <li><b>Локальная</b> (в нее помещаются все переменные и аргумент, объявленные в функции)</li>
                <li>в ES6 <a href="http://jsraccoon.ru/es6-block-scoped-declarations">добавлена</a> <b>блочная</b> область видимости</li>
                <li>Интерпретатор видит переменные, объявленные в родителе и выше</li>
                <li><b>Затенение</b> -- если внутри одной функции объявляется другая с именем переменной, 
                    которое уже существовало в родительской, то на время работы дочерней функции 
                    эта переменная принимает ближайшее значение</li>
            </ul>
        </li>
        <li><h3>Всплытие</h3>
            <ul>Существует 2 условных части исполнения кода:
                <li>Инициализация: код просматривается на предмет инициализации переменных и функций
                    <ul>
                        <li>переменные всплывают только в пределах области видимости</li>
                        <li>функция не всплывет, если объявлена через function expression, 
                            ибо функция окажется в переменной только в момент присваивания </li>
                    </ul>
                </li>
                <li>Выполнение</li>
            </ul>
        </li>
        <li>
            <h3><q>Замыкание -- функция со всеми ее внешними переменными, к которым она имеет доступ</q></h3>
            <ul>
                <li>Очистка мусора при выделении памяти под новую переменную происходит за счет механизма <q>счетик ссылок:</q><br>
                будет ненулевым, если к переменной есть доступ в данный момент 
                (даже неявно, например, при вызове извне функции, в которой данная переменная определена)</li>
                <li><i>NB: Паттерн "модуль" также создает область видимости, чтобы переменные имели внутри нее уникальные имена</i>
                <br>чтобы воспользоваться им, можно использовать IIFE (immediately-invoked function expression):
                <pre><span class="code-format">var func = (function () {
        ...
}());</span></pre><br>теперь из-за механизма "Затенение" испортить функции внутри func нельзя</li>
            </ul>
        </li>
        <li>
            <h3>this и контекст исполнения</h3>
            <ul>
                <li><b>Контекст исполнения</b> тесно связан с областью видимости и содержит ее.<br>
                    <b>Кроме нее</b>, содержит еще и ключевое слово <b>this</b></li>
                <li><b>this</b>
                    <ul>
                        <li>this работает почти так же, как и везде, свойства:
                            <ul>
                                <li>ключевое слово</li>
                                <li>нельзя перезаписать</li>
                                <li>указывает на текущий объект</li>
                                <li><b>можно использовать за пределами объекта</b></li>
                            </ul>
                        </li>
                        <li>this опредяляется в момент интерпретации участка кода (в функции в момент <b>вызова</b>)</li>
                        <li>this зависит от следующих параметров:
                            <ul>
                                <li>Тип участка кода
                                    <ul>
                                        <li>Глобальный:
                                            <ul>
                                                <li>в бразуере в глобальной области видимости this ссылается на window</li>
                                                <li>в NodeJS в глобальной области видимости this ссылается на global</li>
                                                <li><span class="code">console.log();</span> также вызывается 
                                                    у глобального объекта, работает аналогично: <span class="code">this.console.log();</span></li>
                                            </ul>
                                        </li>
                                        <li>NodeJS модуль:
                                            <ul>
                                                <li><span class="code">module.exports.свойство = значение;</span>
                                                работает так же, как и <span class="code">this.свойство = значение;</span></li>
                                                <li>импорт модуля осуществялется при помощи <span class="code">var value = require('./модуль');</span>
                                                <br><i>(NB: в качестве результата получаем "тот самый объект, который мы (кто "мы"?) экспортировали из модуля</i></li>
                                            </ul>
                                        </li>
                                    </ul>
                                </li>
                                <li>Как мы попали на этот участок (кто "мы"?) !! разобраться
                                    <ul>
                                        <li>Если функция объявлена в глобальной области видимости, то this внутри функции ссылается на global/window</li>
                                        <li>Если функция описана в модуле NodeJS, то this вернет объект, экспортируемый этим самым (почему "самым"??) модулем</li>
                                        <li>Если функция вызвана в качестве значения поля объекта, то this будет ссылаться на этот объект</li>
                                        <li>ЕСЛИ <b>функция</b> кладется в память в качестве <b>значения</b> некоторой <b>переменной</b>, 
                                            то this внутри нее будет ссылаться на глобальный объект, <b>притом не важно, 
                                            где была определена функция</b><br><i>(Такое поведение называется <q>заимствование метода</q>)</i></li>
                                        <li>Если функция была передана в качестве callback, то его контекст как бы явно не задан 
                                            и в качестве this подставляется global <b>(Проблема)</b>:
                                            <ul>
                                                <li>сохранить контекст исполнения в переменную: 
                                                    <span class="code">var _this = this;</span></li>
                                                <li>в языке предусмотрена передача контекста исполнения callback'a вторым аргументом
                                                    <br><i>(не все функции, работающие с callback, принимают его контекст выполнения
                                                        -- на помощь придет <span class="code">.bind();</span>, описанный ниже)</i>
                                                </li>
                                            </ul>
                                        </li>
                                        <li>this будет ссылаться на объект, от которого был позван метод даже если
                                            интерпретатор нашел метод в цепочке его прототипов</li>
                                        <hr class="logicDiv">
                                        <li>Методы:
                                            <ul>
                                                <li><span class="code">.call()</span>(вызывается у функции) 
                                                <br><i>вызывает функцию с указанным значением this и индивидуально предоставленными аргументами: 
                                                    <span class="code">function.call(thisArg, arg1, arg2, ...);</span>
                                                <br>может быть использован для использования чужих методов у какого-либо объекта</i></li>
                                                <li><span class="code">.apply()</span>(вызывается у функции)
                                                <br><i>вызывает функцию с указанным значением this и агрументами в виде массива:
                                                    <span class="code">function.apply(thisArg, [arg1, arg2, ...]);</span>
                                                <br>может быть использован для того, чтобы передать аргументы в виде массива (ваш кэп)</i></li>
                                                <li><span class="code">.bind()</span>(вызывается у функции)
                                                <br><i>создает новую функцию, устанавливающую при вызове контекст исполнения 
                                                    this предоставленное значение:
                                                    <span class="code">function.bind(thisArg, arg1, arg2, ...]);</span>
                                                <br>по факту записывается как и передача контекста вторым аргументом, только вместо
                                                <span class="code">}, this);</span> подставляется <span class="code">}.bind(this));</span></i></li>
                                                <li>также .bind() позволяет использовать "частичное применение":
                                                    <pre class="expand"><span class="code-format">var binPow = Math.pow.bind(null, 2);
binPow(2); // 4
binPow(8); // 256</span></pre></li>
                                                <li><i><b>(NB: можно передавать и null в качестве this)</b></i></li>
                                            </ul>
                                        </li>
                                    </ul>
                                </li>
                                <li>Режим работы интерпретатора:
                                    <ul>
                                        <li>В режиме обратной совместимости this совпадает с контекстом, 
                                            в котором была вызвана функция</li>
                                        <li>В строгом режиме для функции, вызванной в global значение this -- undefined</li>
                                        <li>Фунция <span class="code">eval(...);</span> используется в js для того, чтобы
                                        интерпретировать код, написанный в виде строки (в т.ч. можно обращаться ко 
                                        внешним переменным и юзать this):
                                            <ul>
                                                <li>если eval работает внутри метода объекта, то ссылается на этот объект</li>
                                                <li>если eval работает внутри метода объекта неявно (через объявление переменной),
                                                    то ссылается на глобальный объект</li>
                                            </ul>
                                        </li>
                                    </ul>
                                </li>
                            </ul>
                        </li>
                    </ul>
                </li>
            </ul>
        </li>
        <hr><h2>Прототипы и асинхронность, NodeJS</h2>
        <li>
            <h3>Прототипы</h3>
            <ul>
                <li><b>Определение.</b>Представляют собой объекты, на которые указывает ссылка во внутреннем поле [[Prototype]]</li>
                <li>Являются способом избавления от проблемы дублирования кода (аналогично функциям), 
                    выделяя общий части кода в отдельный объект</li>
                <li>Прототипами, как правило, являются некоторые базовые конструкции, 
                    с помощью которых создаются более законченные</li>
                <li><i>Рефакторинг можно осуществить с помощью метода call, но это неудобно, 
                    хотелось бы вызывать методы и свойства, как родные для объекта</i></li>
                <li>Для внедрения прототипирования у объекта существует специально поле [[Prototype]]
                    <br><i>для записи в него ссылки на другой объект существует несколько способов:</i>
                    <ul>
                        <li>Сеттер/геттер <b>__proto__</b>: 
                            <span class="code">объект.__proto__ = другойОбъект</span>
                            <br><i>появился только в ES6</i></li>
                        <li><span class="code">Object.create(...)</span> 
                            -- принимает в качестве параметра желаемый прототип
                            <br>делает больше работы, чем нам здесь надо и создает только новые объекты</li>
                        <li>метод <span class="code">setPrototypeOf(..., ...)</span>
                            -- принимает объект и его желаемый прототип
                            <ul>Ведет себя "лучше", чем __proto__, хотя и схож с ним:
                                <li>выкидывает ошибку при попытке присвоить дерьмо (напр. число)</li>
                                <li>существует обратный метод <span class="code">getPrototypeOf()</span>, 
                                    возвращающий ссылку на прототип (появился раньше)</li>
                            </ul>
                        </li>
                    </ul>
                </li>
                <li>Как это работает:
                    <ul>
                        <li>Если при обращении соответствующего поля у объекта не обнаружено, то
                            интерпретатор будет искать его в прототипе, затем в прототипе прототипа 
                            и так далее, пока не встретит null в поле [[Prototype]]</li>
                        <li>По умолчанию любой объект в поле [[Prototype]] имеет ссылку на 
                            глобальный прототип, содержащий общие методы для всех объектов 
                            (например, <span class="code">Object.prototype.toString())</span>
                            <br><i>уже глобальный прототип имеет <span class="code">null</span>
                                в поле [[Prototype]]</i></li>
                        <li>Существуют более локальные прототипы, например Array.prototype</li>
                        <img class="image-code" src="prototype-chain.png">
                        <li>Циклическое прототипирование выкидывает эксепшен</li>
                        <li>Если попытаться поменять значение, которого нет у объекта, 
                            но есть в его прототипе, то произойдет добавление поля к объекту 
                            и <q>эффект затенение свойства</q>
                            <br><b><i>(Благодаря этому эффекту можно добиться и затенения общих 
                                методов из глобального прототипа)</i></b></li>
                    </ul>
                </li>
            </ul>
        </li>
    </ol>
</body>
</html>